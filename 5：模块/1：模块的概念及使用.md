## 一、模块

### 1、模块的相关概念

**模块**：一系列功能的集合体，可以给其他文件提供功能（数据）

**常用的四种模块**：

- 使用python编写的.py文件
- 把一系列模块组织到一起的文件夹（注：文件夹下有一个__init__.py文件，该文件夹称之为包）
- 使用C编写并链接到python解释器的内置模块
- 已被编译为共享库或DLL的C或C++扩展

### 2、模块的创建和使用

**模块创建及使用步骤**：

- 将具有共性的功能放在一个py文件中，这样的文件就可以称之为模块
- 将封装好的模块对外提供功能
- 在要使用模块功能的地方进行导入 => 使用功能

**模块创建的语法**：

`import` 模块名

**示例1：创建一个模块m1.py**

```python
def t1():pass
def t2():pass
def t3():pass
```

**示例2：调用一个模块m1.py**

```python
import m1     # m1名字就是模块m1的文件对象，存放的是m1文件的地址
```

**导入模块的背后所完成的步骤**：

- 将被导入的模块编译成模块名对应的pyc文件
- 从上至下执行被调用模块的所有代码，形成模块的名称空间，将模块中产生的所有名字存放在模块的名称空间中（如示例1中代码，t1,t2,t3存放在m1模块的名称空间中）
- 在要使用模块的文件(当前文件)的名称空间中产生一个与模块名同名的名字指向模块的名称空间

> 重点：在一个文件中直接使用名字，一定找当前文件中的名字

### 3、模块别名

别名的作用：模块名与当前文件中的名字发生冲突，用起别名解决冲突

别名的语法：import 模块名 as 别名

> 注意：一旦起别名，别名就指向了模块地址，模块名就没有要指向模块地址的必要，那么就失效

**示例1：模块别名**

```python
import m1 as m  #给m1模块起别名叫m,访问模块直接使用别名访问

print(m.a)
```

### 4、模块的多次导入

第一步导入模块，已经完成导入模块的三步骤。如果重复导入了？

多次导入：前两步是重复操作，所以只会在当前文件再产生一个名字指向模块的名称空间

```python
import m1
import m1
# 相当于：a = 10 | a = 10

import m1
import m1 as m
# 相当于：a = 10 | b = a
```

### 5、from...import语法

功能描述：进入模块导入具体的方法

from导入的三步：

- 前两步同import导入
- 第三步：在执行文件起一个与模块中名字相同的变量指向那个名字的地址：a = m1.a

**示例1：from ... import**

```python
from m1 import b   
print(b)
```

**示例2：from ... import as ...**

```python
from m1 import b as bbb  # bbb = m1.b
print(bbb)
```

### 6、模块的两种执行方式

一个 Python 源码文件除了**可以被直接运行**外，还可以**作为模块（也就是库）被导入**。不管是导入还是直接运行，最顶层的代码都会被运行（Python 用缩进来区分代码层次）。而实际上在导入的时候，**有一部分代码我们是不希望被运行的**。

举一个例子来说明一下，假设我们有一个 const.py 文件，内容如下：

```python
PI = 3.14

def main():
    print "PI:", PI

main()
```

我们在这个文件里边定义了一些常量，然后又写了一个 main 函数来输出定义的常量，最后运行 main 函数就相当于对定义做一遍人工检查，看看值设置的都对不对。然后我们直接执行该文件(python const.py),输出：

```python
PI: 3.14
```

现在，我们有一个 area.py 文件，用于计算圆的面积，该文件里边需要用到 const.py 文件中的 PI 变量，那么我们从 const.py 中把 PI 变量导入到 area.py 中：

```python
from const import PI

def calc_round_area(radius):
    return PI * (radius ** 2)

def main():
    print "round area: ", calc_round_area(2)

main()
```

运行 area.py，输出结果：

```python
PI: 3.14
round area:  12.56
```

可以看到，const 中的 main 函数也被运行了，实际上我们是不希望它被运行，提供 main 也只是为了对常量定义进行下测试。这时，`if __name__ == '__main__'` 就派上了用场。把 const.py 改一下：

```python
PI = 3.14

def main():
    print "PI:", PI

if __name__ == "__main__":
    main()
```

然后再运行 area.py，输出如下：

```
round area:  12.56
```

再运行下 const.py，输出如下：

```python
PI: 3.14
```

这才是我们想要的效果。

`if __name__ == '__main__'` 就相当于是 Python **模拟的程序入口**。Python 本身并没有规定这么写，这只是一种编码习惯。由于模块之间相互引用，不同模块可能都有这样的定义，而入口程序只能有一个。到底哪个入口程序被选中，这取决于 `__name__` 的值。

[http://blog.konghy.cn/2017/04/24/python-entry-program/](http://blog.konghy.cn/2017/04/24/python-entry-program/)

### 7、模块的加载顺序

内存 > 内置 > sys.path的路径顺序遍历 自定义模块（自己写的，系统写的第三方，别人写的第三方）

环境变量可以通过`sys.path `方法增加

