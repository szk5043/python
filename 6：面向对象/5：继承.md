## 五、继承

### 1、概述

**什么是继承？**

面向对象编程 (OOP) 语言的一个主要功能就是“**继承**”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”，继承的过程，就是从一般到特殊的过程。在某些  OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。

**为何要用继承？**

- 减少类与类之间代码冗余



**python中继承的特点：**

- Python中一个子类可以同时继承多个父类
- 在继承背景下，Python中的类分为两种：
  - 新式类：定义时继承object类（Python3默认都继承object类）
  - 经典类：什么都不继承（Python2如果显示继承任何类，也不会继承object类）

### 2、类的继承

**示例1：继承定义**

在类名的括号中写入需要继承的类名即可

```python
class Person(object):
    def talk(self):
        print("person is talking...")
 
class BlackPerson(Person):  #继承Person这个类
    def walk(self):  #定义子类自身的walk方法
        print("BlackPerson is walking.....")
 
b = BlackPerson()
b.talk()   #由于继承了父类的talk()方法，所以可以被调用
b.walk()  #调用子类自身的walk方法

'''
#输出
person is talking...
BlackPerson is walking....
'''.
```

**示例2：构造方法的继承**

说明：因为子类有自己的属性，但是又想继承父类的属性，所以需要先继承，再重构

继承类的构造方法2种写法：

1. 经典类写法：父类.__init(self,name,age)
2. 新式类写法：super(子类,self).__init__(name,age)

注：建议使用新式类的写法，因为使用经典类的写法，在多继承的情况下，会出现重复调用参数的可能

代码如下：

```python
class Person(object):
    def __init__(self,name,age):
        self.name = name
        self.age = age
        self.sex = "noraml"
 
    def talk(self):
        print("person is talking...")
 
class BlackPerson(Person):
    def __init__(self,name,age,strength):  #定义时需要传入父类的属性名
        Person.__init__(self,name,age)  #继承父类的构造方法，也可以写成：super(BlackPerson,self).__init__(name,age)
        self.strength = strength   #定义子类本身的属性
        print(self.name,self.age,self.sex)
 
    def walk(self):
        print("BlackPerson is walking.....")
 
b = BlackPerson("xiaogao",18,"strong")

'''
#输出
xiaogao 18 noraml
'''
```

这边不禁的有一个疑问？我不能重新写一遍，我为啥要继承父类中的方法呢？因为你重新写一遍的话，只能继承self.name和self.age，那self.sex怎么办，它也需要重写吗？所以啊，只有把父类中的构造函数全部继承过来，只能用上面这种办法？那它是怎么实现的呢？我们来画一个图：

![images](./images/3.png)

**示例3：子类对父类方法的重写**

说明：如果我对父类中的方法不满意，我可以重写父类中的方法，当然还可以继承父类中的方法，但是我们一般不这样干。

```python
class Person(object):
    def __init__(self,name,age):
        self.name = name
        self.age = age
        self.sex = "noraml"
 
    def talk(self):
        print("person is talking...")
 
class BlackPerson(Person):
    def talk(self):  #重写父类的方法
        Person.talk(self)  #调用父类的方法
        print("BlackPerson is talking ...")
 
    def walk(self):
        print("BlackPerson is walking.....")
 
b = BlackPerson("xiaogao",18)  #子类不写，则继承父类的构造方法
b.talk()
b.walk()

'''
#输出
person is talking...
BlackPerson is talking ...
BlackPerson is walking.....
'''
```

其实重写不是上面说的那么简单，只需要子类的方法名和父类的中的方法名一样就算重写了，其实不然，那怎么样才算重写呢？

**重写的条件：**

1. 重写方法的方法名必须和父类中被重写的方法名一模一样
2. 重写方法的传入的参数名和参数的个数必须和父类中被重写的方法一样

我们再来看看下面的例子：

```python
class Person(object):
 
    def talk(self,food):
        print("person is talking...{0}".format(food))
 
class BlackPerson(Person):
 
    def talk(self):  #方法名和父类的方法名一样，但是少了一个food参数
        print("BlackPerson is talking ...")
 
b = BlackPerson("xiaogao",18,"strong")
b.talk()
 
'''
#输出
BlackPerson is talking ...
'''
```

有些同学说，这明明是重写了呀！其实不是重写，根据重写的条件明显两个方法的传入参数名和参数的个数都不一样，其实上面这种只是子类自己写了一个talk方法，只是名字一样，但是传入的参数和参数的个数不一样，并不是重写了父类中的方法。下面这个才是真正的重写：

```python
class Person(object):
 
    def talk(self,food):
        print("person is talking...{0}".format(food))
 
class BlackPerson(Person):
 
    def talk(self,food):  #重写父类的方法(方法名和传入的参数名以及参数的个数与父类的方法一样)
        print("BlackPerson is talking ...{0}".format(food))
 
b = BlackPerson("xiaogao",18,"strong")
b.talk("hotdog")
 
'''
#输出
BlackPerson is talking ...hotdog
'''
```

### 3、在继承背景下的属性查找（单继承与多继承）

 在python还支持多继承，但是一般我们很少用，有些语言干脆就不支持多继承，有多继承，就会带来两个概念，经典类和新式类，下面我就来学学什么是多继承，什么是经典类和新式类？

**示例1：多继承**：子类可以继承多个父类，就叫多继承

```python
class SchoolMember(object):  #SchoolMember类
    '''学校成员基类'''
    def tell(self):
        print("the schoolmeber is tell...")
 
class School(object):     #School类
    """学校类"""
    def open_branch(self,addr):
        print("openning a new branch in",addr)
 
class Teacher(SchoolMember,School):   #子类Teacher同时继承了SchoolMember,School两个类
    "讲师类"
    def teaching(self):
        "讲课方法"
        print("Teacher xiaogao is teaching python")
 
t1 = Teacher()
t1.tell()   #拥有父类SchoolMember的tell方法
t1.open_branch("shanghai")  #拥有父类School的open_branch方法
```

### 4、新式类与经典类的区别（继承属性查找的实现原理）

（1）、新式类

新式类定义时必须继承object类，被定义继承了object类的，就叫做新式类

```python
class Person(object):  #继承object类
    "新式类"
```



### 5、在子类派生的新方法中重用父类功能的方式二