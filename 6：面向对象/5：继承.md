## 五、继承

### 1、概述

之前我们说到了类的公有属性和类的私有属性，其实就是类的封装，下面我们来讲讲继承，是面向对象的第二大特性。

面向对象编程 (OOP) 语言的一个主要功能就是“**继承**”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”，继承的过程，就是从一般到特殊的过程。在某些  OOP 语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。

继承概念的实现方式主要有2类：实现继承、接口继承。

1. 实现继承是指使用基类的属性和方法而无需额外编码的能力。
2. 接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力(子类重构爹类方法)。

在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。

抽象类仅定义将由子类创建的一般属性和方法，OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段

### 2、类的继承

**示例1：继承定义**

在类名的括号中写入需要继承的类名即可

```python
class Person(object):
    def talk(self):
        print("person is talking...")
 
class BlackPerson(Person):  #继承Person这个类
    def walk(self):  #定义子类自身的walk方法
        print("BlackPerson is walking.....")
 
b = BlackPerson()
b.talk()   #由于继承了父类的talk()方法，所以可以被调用
b.walk()  #调用子类自身的walk方法

'''
#输出
person is talking...
BlackPerson is walking....
'''.
```

**示例2：构造方法的继承**

说明：因为子类有自己的属性，但是又想继承父类的属性，所以需要先继承，再重构

继承类的构造方法2种写法：

1. 经典类写法：父类.__init(self,name,age)
2. 新式类写法：super(子类,self).__init__(name,age)

注：建议使用新式类的写法，因为使用经典类的写法，在多继承的情况下，会出现重复调用参数的可能

代码如下：

```python
class Person(object):
    def __init__(self,name,age):
        self.name = name
        self.age = age
        self.sex = "noraml"
 
    def talk(self):
        print("person is talking...")
 
class BlackPerson(Person):
    def __init__(self,name,age,strength):  #定义时需要传入父类的属性名
        Person.__init__(self,name,age)  #继承父类的构造方法，也可以写成：super(BlackPerson,self).__init__(name,age)
        self.strength = strength   #定义子类本身的属性
        print(self.name,self.age,self.sex)
 
    def walk(self):
        print("BlackPerson is walking.....")
 
b = BlackPerson("xiaogao",18,"strong")

'''
#输出
xiaogao 18 noraml
'''
```

这边不禁的有一个疑问？我不能重新写一遍，我为啥要继承父类中的方法呢？因为你重新写一遍的话，只能继承self.name和self.age，那self.sex怎么办，它也需要重写吗？所以啊，只有把父类中的构造函数全部继承过来，只能用上面这种办法？那它是怎么实现的呢？我们来画一个图：

![images](./images/3.png)

**示例3：子类对父类方法的重写**

说明：如果我对父类中的方法不满意，我可以重写父类中的方法，当然还可以继承父类中的方法，但是我们一般不这样干。

```python
class Person(object):
    def __init__(self,name,age):
        self.name = name
        self.age = age
        self.sex = "noraml"
 
    def talk(self):
        print("person is talking...")
 
class BlackPerson(Person):
    def talk(self):  #重写父类的方法
        Person.talk(self)  #调用父类的方法
        print("BlackPerson is talking ...")
 
    def walk(self):
        print("BlackPerson is walking.....")
 
b = BlackPerson("xiaogao",18)  #子类不写，则继承父类的构造方法
b.talk()
b.walk()

'''
#输出
person is talking...
BlackPerson is talking ...
BlackPerson is walking.....
'''
```

其实重写不是上面说的那么简单，只需要子类的方法名和父类的中的方法名一样就算重写了，其实不然，那怎么样才算重写呢？

**重写的条件：**

1. 重写方法的方法名必须和父类中被重写的方法名一模一样
2. 重写方法的传入的参数名和参数的个数必须和父类中被重写的方法一样

我们再来看看下面的例子：

```python
class Person(object):
 
    def talk(self,food):
        print("person is talking...{0}".format(food))
 
class BlackPerson(Person):
 
    def talk(self):  #方法名和父类的方法名一样，但是少了一个food参数
        print("BlackPerson is talking ...")
 
b = BlackPerson("xiaogao",18,"strong")
b.talk()
 
'''
#输出
BlackPerson is talking ...
'''
```

有些同学说，这明明是重写了呀！其实不是重写，根据重写的条件明显两个方法的传入参数名和参数的个数都不一样，其实上面这种只是子类自己写了一个talk方法，只是名字一样，但是传入的参数和参数的个数不一样，并不是重写了父类中的方法。下面这个才是真正的重写：

```python
class Person(object):
 
    def talk(self,food):
        print("person is talking...{0}".format(food))
 
class BlackPerson(Person):
 
    def talk(self,food):  #重写父类的方法(方法名和传入的参数名以及参数的个数与父类的方法一样)
        print("BlackPerson is talking ...{0}".format(food))
 
b = BlackPerson("xiaogao",18,"strong")
b.talk("hotdog")
 
'''
#输出
BlackPerson is talking ...hotdog
'''
```

### 3、类继承练习

```python
class SchoolMember(object):
    '''学校成员基类'''
 
    member = 0  #设置类属性
    def __init__(self,name,age,sex):
        self.name = name
        self.age = age
        self.sex =sex
        self.enroll()  #每次生成一个对象注册一次
    def enroll(self):
        "注册"
        print("just enroll a new school member [{0}]".format(self.name))
        SchoolMember.member += 1
 
    def tell(self):
        print("------info:{0}-----".format(self.name))
        for k,v in self.__dict__.items():  #__dict__()函数是获取对象的属性，以字典的形式返回
            print("\t",k,v)
        print("------end--------")
 
    def __del__(self):
        print("开除了[{0}]...".format(self.name))
        SchoolMember.member -= 1
 
class Teacher(SchoolMember):
    "讲师类"
 
    def __init__(self,name,age,sex,salary,course):
        SchoolMember.__init__(self,name,age,sex)
        self.salary = salary
        self.course = course
 
    def teaching(self):
        "讲课方法"
        print("Teacher [{0}] is teaching [{1}]".format(self.name,self.course))
 
class Student(SchoolMember):
    "学生类"
    def __init__(self,name,age,sex,couser,tuition):
        SchoolMember.__init__(self,name,age,sex)
        self.couser = couser
        self.tuition = tuition
        self.amount = 0
 
    def pay_tuition(self,amount):
        print("student [{0}] has just paied [{1}]".format(self.name,amount))
        self.amount += amount
 
t1 = Teacher("xiaogao",18,"F*M",3000,"Python")
s1 = Student("shuaigao",19,"M","PYS15",300000)
s2 = Student("gaogao",12,"M","PYS15",11000)
 
print(SchoolMember.member)
del s1  #删除一个变量
t1.tell()
s2.tell()
print(SchoolMember.member) #会执行__del__函数

'''
#输出
just enroll a new school member [xiaogao]
just enroll a new school member [shuaigao]
just enroll a new school member [gaogao]
3
开除了[shuaigao]...
------info:xiaogao-----
     salary 3000
     sex F*M
     course Python
     name xiaogao
     age 18
------end--------
------info:gaogao-----
     couser PYS15
     sex M
     name gaogao
     amount 0
     tuition 11000
     age 12
------end--------
2
开除了[gaogao]...
开除了[xiaogao]...
'''
```

