## 四、网络编程之粘包问题

### 1、概述

首先 ,  `粘包现象只出现在TCP中`  ,  为什么说只有在TCP中才会发生粘包现象 , 先来详细解释一下TCP与UDP吧：

> **TCP** 

TCP (transprot control protocol, 传输控制协议) 是面向连接的 , 面向流的 , 提供高可靠性服务 .   收发两端都有要一一对应的socket(一对一模式) , 因此发送端为了将多个发往接收端的包 , 更有效的发到对方 ,  使用了优化方法(Nagle算法) , **将多次间隔较小且数据量小的数据 , 合并成一个大的数据块 , 然后进行封包** . 必须提供科学的拆包机制 , 才能进行合理的分辨 , 所以说面向流的通信是无消息保护边界的

> **UDP** 

UDP(user datagram protocol, 用户数据报协议) 是无连接的 , 面向消息的 , 提供高效率服务 .  不使用块的合并优化算法 , 由于UDP支持的是一对多的模式 , 所以接收端的skbuff (套接字缓冲区)  采用了链式结构来记录每一个到达的UDP包 , 在每个UDP包中就有了消息头 (消息来源地址 , 端口等信息) , 这样 , 对于接收端来说 ,  就容易进行区分处理了 . 即面向的通信是有消息保护边界的

> **区别** 

TCP是基于数据流的 , 于是收发的消息不能为空 , 这就需要在客户端和服务端都添加空消息的处理机制 , 防止程序卡住 , 而UDP是基于数据报的 , 就算收发空内容 , 也不是空消息 , UDP协议会自动帮你封装上消息头

### 2、粘包现象发生的原因

**①、发送方引起的粘包**

这种情况下引起的粘包是TCP协议本身造成的 , TCP为了提高传输效率 , 发送方往往要收集到足够多的数据后才发送一个TCP段 `(超过时间间隔也会发送,时间间隔是很短的)`  , 如果连续几次需要发送的数据都很少 , 通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去 , 所以几次的数据到接收方时就粘成一包了

如下：

```python
# 发送方第一次发送
send(b"I'm ")
# 立马第二次,不超过时间间隔
send(b"Lyon")
-------------
# 接收
data = recv(1024)
# 收到的是两次粘在一起的数据
print(data.decode())
# 打印结果: I'm Lyon
```

**②、接收方引起的粘包**

这种情况引起的粘包则是因为接收方不及时接收缓冲区的数据包造成的 , 比如发送方一次发送了10字节的数据 , 而接收方只接收了2字节 , 那么剩余的8字节的数据将都在缓冲区等待接收 , 而此时发送方又发送了2字节的数据 , 过了一会接收方接收了20字节(大于剩余10字节) , 接收完毕 , 缓冲区剩余的数据就和第二次发送的数据粘成了一个包 , 产生粘包。

如下：

```python
# 发送4字节内容 
send(b"I'm ") # 接收1字节,缓冲区还有3字节 
data1 = recv(1) 
print("data1:",data1) 
# 发送4字节内容,粘到缓冲区中剩余的3字节后面 
send(b"Lyon") 
# 接收7字节,接收完毕 
data2 = recv(7) 
print("data2:",data2) 

'''
打印结果:
data1:I
data2:'m Lyon
''' 
```

**SO : 所以所谓粘包问题主要还是因为接收方不知道消息之间的界限 , 不知道一次性提取多少字节的数据所造成的**

### 3、解决粘包问题